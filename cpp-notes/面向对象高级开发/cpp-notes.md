本笔记是基于侯捷的cpp视频 由于已经学过cpp 本笔记只做总结和查漏补缺 培养正规军的写法和高级技巧  

## C++面向对象高级开发（上）  
### 构造函数  
**构造函数初始化要尽量去用**  

**Q:内联函数是什么？**  
A:内联函数是在class内部定义的函数，有宏MACRO的好处但是没有宏的缺点，但是函数是否内联由编译器决定，如果函数很复杂，即使在class内部或给了`inline`关键字也不会内联，`inline`关键字只是一个建议    

**Q:什么时候用析构函数 什么时候不用析构函数**  
A:一般不用指针的类不需要析构函数，用指针的类需要析构函数，因为要进行内存管理  

**Q:构造函数什么时候可以重载 什么时候不能**  
A：在class内部，函数是可以重载的，相同函数名类型不同可以有不同的功能，但是如果构造函数有默认值，那么空的构造函数就不能重载了  
如`complex() : re(0), im(0) {}`和`complex(double r = 0, double i = 0): re (r), im (i) {}`冲突  

### 参数传递与返回值  
#### 单例模式singleton  
**构造函数可以放在private里吗？可以**  
构造函数如果放在private里，则无法通过声明来构造函数，但是单例模式通过将构造函数放在private里，让外界只能对这个class进行一次调用  
```cpp
class A {
public:
    static A& getInstance();
    setup() {...}
private:
    A();
    A(const A& rhs); //重载  
    ...
};

A& A::getInstance()
{
    static A a;
    return a;
}
```
调用方法`A::getInstance().setup()`  

#### 常量成员函数const  
**Q：函数的后面加const有什么用，不加会怎么样**  
A：表示不会改变数据内容，不加的话，如果构造一个const类型的对象，然后使用成员函数，会报错，因为const类型意思是不会改变这个对象，但是使用的成员函数没有const，意思是可变，就会报错  

#### 参数传递(by value/reference(to const))  
养成习惯一般传引用不要传值，传值如果很多的话要进行拷贝，会有内存开销，而传引用相对于传地址，速度很快，如果不希望修改传递的参数的值，可以在引用前面加个const，这样如果要对传递的值进行修改编译器会报错。

#### 返回值传递  
也**尽量**用reference，是可以的情况下，有时候不可以，如果传递的东西需要在函数内部创建新的东西来作为结果，这个时候这个东西是local的，函数一结束这个东西的生命周期也结束了，所以传引用不可以，而如果传递的东西可以用本身，那就可以用引用  


传递者无需知道接收者是以reference形式接收  
 
#### 友元friend  
友元可以自由取得friend的private成员，声明了友元，那么在友元class里可以直接使用该类的数据  
相同class的各个对象互为友元，在public里声明的函数可以直接使用private数据，没有打破封装  

### 操作符重载与临时成员  
重载的时候`this`不能写出来，会报错，但是在函数里面可以用  

一元操作符重载有时，可以用reference传递，二元操作符重载一定不能，因为他们返回的必定是local object，只要返回local object的都不能用reference传递，比如一元的负号    


 


